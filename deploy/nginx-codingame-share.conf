# Nginx vhost for codingame-share subdomain with WebSocket proxy and TLS placeholders
#
# What you must fill manually:
# - Replace all occurrences of "codingame-share.insalgo.fr" with your real subdomain if different.
# - Set the correct SSL certificate paths (ssl_certificate and ssl_certificate_key).
#   If you use Certbot with --nginx, it will fill these automatically.
# - Adjust the upstream port if your Go app does not listen on 127.0.0.1:8080.
#
# Typical enable steps (Debian/Ubuntu):
#   sudo ln -s /etc/nginx/sites-available/codingame-share /etc/nginx/sites-enabled/codingame-share
#   sudo nginx -t && sudo systemctl reload nginx
#
# If using Certbot:
#   sudo certbot --nginx -d codingame-share.insalgo.fr --redirect

# Optional: Handle WebSocket Upgrade header cleanly (requires http context; ok in this file)
# If your distro forbids 'map' here, move it to /etc/nginx/conf.d/websocket_map.conf
map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}

server {
    listen 80;
    listen [::]:80;
    server_name codingame-share.insalgo.fr;  # TODO: set your subdomain

    # ACME challenge (Letâ€™s Encrypt HTTP-01)
    location /.well-known/acme-challenge/ {
        root /var/www/html;
    }

    # Redirect all other HTTP traffic to HTTPS
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name codingame-share.insalgo.fr;  # TODO: set your subdomain

    # ===== TLS (fill these or let certbot manage them) =====
    ssl_certificate     /etc/letsencrypt/live/codingame-share.insalgo.fr/fullchain.pem;  # TODO
    ssl_certificate_key /etc/letsencrypt/live/codingame-share.insalgo.fr/privkey.pem;    # TODO

    # Reasonable TLS defaults
    ssl_session_timeout 1d;
    ssl_session_cache shared:SSL:50m;
    ssl_session_tickets off;

    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers off;

    # HSTS (enable after confirming HTTPS works)
    add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload" always;

    # Optional extra security headers (your app already sets some)
    add_header X-Content-Type-Options nosniff always;
    add_header X-Frame-Options DENY always;
    add_header Referrer-Policy no-referrer always;

    # Increase or limit request size as needed
    client_max_body_size 10m;

    # ===== Reverse proxy to the Go app (HTTP on localhost:8080) =====
    # IMPORTANT: The Go app should have:
    #   ALLOWED_ORIGINS=https://codingame-share.insalgo.fr
    #   ALLOWED_HOSTS=codingame-share.insalgo.fr
    # Otherwise, WS origin checks may fail behind TLS-terminating Nginx.

    # General HTTP traffic (static + API served by the Go app)
    location / {
        proxy_pass http://127.0.0.1:8080;  # TODO: adjust if your app listens elsewhere
        proxy_http_version 1.1;

        proxy_set_header Host               $host;
        proxy_set_header X-Real-IP          $remote_addr;
        proxy_set_header X-Forwarded-For    $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto  https;

        proxy_read_timeout 60s;
        proxy_send_timeout 60s;
    }

    # WebSocket endpoint
    location /ws {
        proxy_pass http://127.0.0.1:8080;  # TODO: adjust if your app listens elsewhere
        proxy_http_version 1.1;

        proxy_set_header Upgrade            $http_upgrade;
        proxy_set_header Connection         $connection_upgrade;
        proxy_set_header Host               $host;
        proxy_set_header X-Real-IP          $remote_addr;
        proxy_set_header X-Forwarded-For    $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto  https;

        # Long-lived connections
        proxy_read_timeout 1d;
        proxy_send_timeout 1d;
    }

    # Optional: custom log files
    # access_log /var/log/nginx/codingame-share.access.log;
    # error_log  /var/log/nginx/codingame-share.error.log warn;
}
